Home模块组件拆分
 先把静态页面完成
 拆分出静态组件
 获取服务器的数据进行展示
 动态业务完成

 postApi 测试接口
 --经过postApi的测试，接口没问题
 --如果服务器返回的是code是200，说明成功了
 --整个项目，接口前缀都要 /api 字样

 6.axios 二次封装

 6.1 为什么需要进行二次封装 axios
 请求拦截器、响应拦截器：
        请求拦截器可以在发请求之前处理一些业务
        响应拦截器：当服务器数据返回以后，可以处理一些事情
6.2 在项目当中经常 API 文件夹 【axios】

7 接口统一管理

7.1 跨域问题
    什么是跨域：协议、域名、端口号不同请求，称之为跨域

8. nprogress 进度条的使用
start: 进度条开始
done：进度条结束
进度条颜色可以修改 去样式那里该颜色

9.vuex状态管理库   
vuex是官方提供的一个插件，集中式管理库，集中式管理项目种组件共用的数据
如果项目很小，则不需要vuex vuex适合项目比较大，组件较多，数据多，数据维护困难的项目
state   actions mutations getters  modules

9.2 vuex实现模块化开发
    如果项目过大，数据、组件、接口过多，那就用模块化开发

10. 完成TypeNav 三级联动展示数据业务

三级联动组件的路由的跳转与传递参数

三级联动用户可以点击的有：一级、二级、三级分类，当你点击的时候 Home模块跳转到Search模块，一级会把用户选中的产品（产品名字、产品Id）在路由跳转时，进行传递

路由跳转：声明式导航：router-link
         编程式导航：push | replace
    
三级联动：如果使用声明式导航router-link，可以实现路由的跳转与传递参数
但是需要注意，会出现卡顿现象
router-link： 可以是一个组件，当服务器的数据返回之后，循环出了很多的router-link【创建组件实例】1000+
创建组件实例的时候，一瞬间创建太多，会导致很消耗内存，所以才会出现卡顿现象

复习：
1）商品分类的三级列表由静态变为动态形式【获取服务器数据：解决跨域问题】
2）函数防抖与节流【面试频率很高】
3）路由跳转：声明式导航、编程式导航
编程式导航解决这个问题：自定义属性

1）开发Search模块里的TypeNav商品分类菜单（过渡动画效果）
过渡动画：前提组件|元素务必要有 v-if 和 v-show 指令才可以进行过渡动画

2) 现在商品分类三级列表可以优化? 
对性能进行优化，让请求数据只发生一次放在App的 Mounted挂载生命周期里
因为 App组件的请求只会发生一次

3） 合并 query 和 params 参数
这里就是 要弄清楚 router路由器 和 route 路由的区别 路由器里面存放着总的 query和params 因为Search组件需要 Header的参数和 TypeNav的参数，所以需要把这两个的参数合并起来 让 router路由器接收到全部的参数

4） 开发Home首页的ListContainer和Floor组件，
需要了解：服务器返回的数据（接口）只有商品分类菜单的分类数据，ListContainer和Floor组件的数据是没有的
mock数据（模拟数据）：如果你想mock数据，需要用到一个插件 mock.js

mockjs使用步骤：
1.在项目当中src文件夹中创建一个mock文件夹
2.准备json数据(mock文件夹中创建相应的json文件) -- 格式化一下，别留有空格
3.把mock数据需要的图片放置在public文件夹下中【public文件夹在打包的时候，会把相应的文件原封不动的打包到dist文件夹】
4.创建mockServe.js来模拟数据
5.把mockServe.js文件在入口文件引入（至少需要执行一次，才能模拟数据）

5) ListContainer组件开发重点
安装Swiper插件：安装5版本

6) swiper使用
1.引入依赖包（swiper.js | swiper.css）
2.页面中的结构必须要有
3.初始化swiper实例，给轮播图添加动态效果

2）开发Floor组件
切记：仓库当中的state的数据格式，别瞎写，数据格式取决于服务器返回的数据
getFloorList这个actions需要在 home 组件发 不能在Floor组件内部发，因为我们要v-for遍历Floor组件
v-for 也可以在自定义标签下（组件）使用

组件间通信的方式有哪些？   （面试频率极高）
props：用于父子组件通信
自定义事件：$on  $emit 可以实现子给父通信
全局事件总线： $bus
pubsub-js：vue中几乎不用，
插槽
vuex

3)把首页当中轮播图拆分为一个共用全局组件，
这边我没改，我觉得没必要，到时候用ElementUI的时候就有组件轮播图的
但是不可否认它的好处：如果项目中多次出现一样的这个轮播图效果，注册一次全局组件，就可以在任意地方使用，

4）Search模块开发？
1.先是静态页面 + 静态组件拆分出来
2.发请求（API）
3.vuex（三连环）
4.组件获取仓库数据，动态显示数据

7) 开发产品详情页面
1.静态页面（需要注册为路由组件）
当点击商品图片时，跳转到详情页面，跳转时需要带上产品ID

2.API--> 请求接口

3.： vuex --> 获取产品详情信息
vuex中还需要在新增一个detail模块
并且需要合并

1)加入购物车按钮
1.1路由跳转之前发请求
1.2成功路由跳转与参数传递
浏览器存储功能：HTML5中新增的，本地存储和会话存储
本地存储：持久化的---
会话存储：非持久化---会话结束就会消失
1.3失败提示失败信息

2）addCartSuccess
2.1查看详情
2.2查看购物车

3）购物车
3.1购物车静态组件，需要修改样式结构
调整css让各个项目对齐，删除第三项 15 35 10 17 10 13
3.2 向服务器发起ajax请求，获取购物车数据
3.3 UUID临时游客身份
3.4 动态展示购物车

4） 修改购物车产品的数量（需要发请求，参数理解）

5）修改产品个数【函数节流】

6）删除某一个产品

7）全选   

8）删除选中全部产品的操作
注意:没有一次删除很多产品的接口,但是有通过ID来删除商品的接口【但是一次只能删除一个】
Promise.all([p1,p2,p3])
p1|p2|p3 每一个都是Promise对象，如果有一个对象失败，则都失败，如果都成功，则成功

9）全选操作

1）登录与注册！！！！
登录与注册（git） ，很重要
1.1登录与注册的静态组件
1.2 assets文件夹  放置全部组件共用静态资源
1.3 在样式当中也可以使用@符号【src别名】，切记在前面加上 ~

2) 注册的业务
2.1 注册业务|登录业务中表单验证先不处理【最后一天一起处理】

3)登陆业务
3.1注册---- 通过数据库存储用户信息（名字、密码）
3.2 登录---登录成功的时候，后台为了区分你这个用户是谁，服务器下发token【令牌：唯一标识符】
登录接口：不太完美，一般都是只有token，我们再持久化存储token，【带着token找服务器要用户数据进行展示】

4）token令牌理解

vuex仓库存储数据---不是持久化！！！！  一刷新数据就没了 

1）

Vue组件库:   ElementUI <pc端>  vant <移动端>

个人中心完成

图片懒加载
npm里面的 vue-lazy 然后自己看怎么用

路由懒加载
当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。

！！ 打包  npm run build
项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法最准确得知是哪里的代码报错
有了 map 就可以像未加密的代码一样，准确的输出是哪一行哪一列有错
所以该文件如果项目不需要是可以去掉的
在vue.config.js里配置
productionSourceMap:false
或者直接删除map文件

打完包就需要服务器了，可以购买服务器，或者不买
1.阿里云
2.腾讯云

设置安全组，让服务器一些端口号打开
利用shell工具登录服务器
linux的常用指令： cd 跳转目录    ls 查看   mkdir 创建目录   pwd 查看绝对路径